<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Fetch & Process App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            margin-top: 5rem; /* Space for fixed navbar */
        }
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #1f2937; /* Dark background */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 1rem 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
        }
        .navbar a {
            color: #d1d5db; /* Light gray text */
            padding: 0.75rem 1.25rem;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0.5rem;
            transition: background-color 0.2s, color 0.2s;
        }
        .navbar a:hover {
            background-color: #374151; /* Darker gray on hover */
            color: white;
        }
        .navbar a.active {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background-color: #ffffff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem; /* rounded-xl */
        }
        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #374151; /* Gray-700 */
        }
        .input-group input[type="text"],
        .input-group input[type="password"],
        .input-group input[type="number"],
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db; /* Gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            font-size: 1rem;
            color: #1f2937; /* Gray-900 */
            transition: border-color 0.2s;
        }
        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #4f46e5; /* Indigo-600 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5); /* Indigo-500 with opacity */
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Indigo-700 */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray-500 */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .btn:disabled {
            background-color: #9ca3af; /* Gray-400 */
            cursor: not-allowed;
        }
        .card {
            background-color: #f9fafb; /* Gray-50 */
            border: 1px solid #e5e7eb; /* Gray-200 */
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #f3f4f6;
            font-weight: 600;
            color: #4b5563;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .tab-content {
            border-radius: 0.5rem;
            padding: 1.5rem;
            background-color: white;
        }

        /* Desktop-like Notifications */
        #notificationContainer {
            position: fixed;
            top: 6rem; /* Below navbar */
            right: 1rem;
            z-index: 1050;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            width: 300px;
        }
        .notification-item {
            padding: 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideInRight 0.3s ease-out forwards;
        }
        .notification-item.success {
            background-color: #d1fae5; /* Green-100 */
            color: #065f46; /* Green-800 */
            border: 1px solid #34d399; /* Green-400 */
        }
        .notification-item.error {
            background-color: #fee2e2; /* Red-100 */
            color: #991b1b; /* Red-800 */
            border: 1px solid #ef4444; /* Red-500 */
        }
        .notification-item.info {
            background-color: #dbeafe; /* Blue-100 */
            color: #1e40af; /* Blue-800 */
            border: 1px solid #60a5fa; /* Blue-400 */
        }
        .notification-item.warning {
            background-color: #fffacd; /* Light yellow */
            color: #8b4513; /* Brown/Orange */
            border: 1px solid #ffcc00; /* Yellow */
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .notification-item.fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="p-4 bg-gray-100">
    <!-- Top Navbar -->
    <nav class="navbar">
        <ul class="flex space-x-2">
            <li><a href="#" class="tab-link active" data-tab="dbConfigTab">DB Configuration</a></li>
            <li><a href="#" class="tab-link" data-tab="inputsTab">Inputs (Rename/Reorder)</a></li>
            <li><a href="#" class="tab-link" data-tab="configureAppTab">App Configuration</a></li>
            <li><a href="#" class="tab-link" data-tab="fetchTableDataTab">Fetch Table Data</a></li>
            <li><a href="#" class="tab-link" data-tab="pipelineTab">Run Pipeline</a></li>
        </ul>
    </nav>

    <div class="container bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Data Pipeline Microservice</h1>

        <div>
            <!-- Tab Contents -->
            <!-- DB Configuration Tab -->
            <div id="dbConfigTab" class="tab-content">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Database Configuration Management</h2>
                
                <div class="mb-6">
                    <div class="flex space-x-4 mb-4">
                        <button class="btn btn-primary" onclick="showDbForm('external')">Configure External DB</button>
                        <button class="btn btn-secondary" onclick="showDbForm('local')">Configure Local SQLite DB</button>
                    </div>
                </div>

                <div id="externalDbForm" class="card hidden">
                    <h3 class="text-xl font-medium text-gray-600 mb-4">External DB Configuration</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="input-group">
                            <label for="ext_db_type">DB Type (e.g., postgresql, mysql, mssql)</label>
                            <input type="text" id="ext_db_type" value="mssql" placeholder="e.g., postgresql, mysql, mssql" class="input-field">
                        </div>
                        <div class="input-group">
                            <label for="ext_host">Host</label>
                            <input type="text" id="ext_host" value="65.108.38.170" placeholder="e.g., localhost, 127.0.0.1" class="input-field">
                        </div>
                        <div class="input-group">
                            <label for="ext_port">Port</label>
                            <input type="text" id="ext_port" value="1400" placeholder="e.g., 5432, 3306" class="input-field">
                        </div>
                        <div class="input-group">
                            <label for="ext_db_name">DB Name</label>
                            <input type="text" id="ext_db_name" value="asterminal_db" placeholder="e.g., mydatabase" class="input-field">
                        </div>
                        <div class="input-group">
                            <label for="ext_username">Username</label>
                            <input type="text" id="ext_username" value="sa" placeholder="e.g., user" class="input-field">
                        </div>
                        <div class="input-group">
                            <label for="ext_password">Password</label>
                            <input type="password" id="ext_password" value="your_sa_password_here" placeholder="e.g., password" class="input-field">
                        </div>
                        <div class="input-group md:col-span-2">
                            <label for="ext_driver">ODBC Driver (Optional, e.g., 'ODBC Driver 17 for SQL Server' for MSSQL)</label>
                            <input type="text" id="ext_driver" value="ODBC Driver 17 for SQL Server" placeholder="Leave empty if not needed" class="input-field">
                        </div>
                    </div>
                    <div class="input-group mb-4">
                        <label for="ext_sql_query">SQL Query (This query will be associated with this saved DB config)</label>
                        <textarea id="ext_sql_query" rows="5" placeholder="SELECT * FROM products LIMIT 10;" class="input-field">SELECT id, product_name, price FROM Products WHERE ProductID < 10;</textarea>
                    </div>
                    <button class="btn btn-primary w-full" onclick="saveDbConfig('external')">Save External DB Config</button>
                </div>

                <div id="localDbForm" class="card hidden">
                    <h3 class="text-xl font-medium text-gray-600 mb-4">Local SQLite DB Configuration</h3>
                    <div class="input-group mb-4">
                        <label for="loc_db_path">DB File Path (or :memory: for in-memory)</label>
                        <input type="text" id="loc_db_path" value=":memory:" placeholder="e.g., :memory: or my_local_db.sqlite" class="input-field">
                    </div>
                    <div class="input-group mb-4">
                        <label for="loc_initial_sql">Initial SQL (Optional, for setting up in-memory or new file DB)</label>
                        <textarea id="loc_initial_sql" rows="5" placeholder="CREATE TABLE users (id INTEGER, name TEXT); INSERT INTO users VALUES (1, 'Alice');" class="input-field">CREATE TABLE IF NOT EXISTS sample_data (id INTEGER PRIMARY KEY, value TEXT); INSERT INTO sample_data (value) VALUES (1, 'Hello'), (2, 'World');</textarea>
                    </div>
                    <div class="input-group mb-4">
                        <label for="loc_sql_query">SQL Query (This query will be associated with this saved DB config)</label>
                        <textarea id="loc_sql_query" rows="5" placeholder="SELECT * FROM users;" class="input-field">SELECT * FROM sample_data;</textarea>
                    </div>
                    <button class="btn btn-primary w-full" onclick="saveDbConfig('local')">Save Local DB Config</button>
                </div>

                <div class="mt-6">
                    <h3 class="text-xl font-medium text-gray-700 mb-2">Stored DB Configurations</h3>
                    <div class="flex space-x-2 mb-4">
                        <button class="btn btn-secondary" onclick="listDbConfigs()">Refresh List</button>
                        <button class="btn btn-secondary" onclick="clearAllDbConfigs()">Clear All DBs</button>
                    </div>
                    <div id="dbConfigList" class="mt-4"></div>
                </div>
            </div>

            <!-- Inputs Tab -->
            <div id="inputsTab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Column Inputs (Rename / Reorder)</h2>
                <div id="inputFormsContainer">
                    <!-- Dynamic input forms will be added here -->
                </div>
                <div class="flex flex-wrap gap-2 mt-4">
                    <button class="btn btn-secondary" onclick="addInputField()">Add New Input</button>
                    <button class="btn btn-secondary" onclick="clearAllInputs()">Clear All Inputs</button>
                    <button class="btn btn-secondary" onclick="listInputs()">Refresh Inputs List</button>
                    <button class="btn btn-primary" onclick="saveAllInputs()">Save All Inputs</button>
                </div>
                
                <div id="inputsList" class="mt-4"></div>
            </div>

            <!-- App Configuration Tab -->
            <div id="configureAppTab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Application Configuration for Pipeline</h2>
                <div class="card">
                    <div class="input-group mb-4">
                        <label for="config_file_type">Output File Type</label>
                        <select id="config_file_type" class="input-field">
                            <option value="csv">CSV</option>
                            <option value="json">JSON</option>
                            <option value="xlsx">XLSX</option>
                            <option value="zip">ZIP</option>
                        </select>
                    </div>
                    <div class="input-group mb-4">
                        <label for="config_tmp_dir">Temporary Directory (Optional, overrides global TEMP_DIR)</label>
                        <input type="text" id="config_tmp_dir" placeholder="e.g., custom_tmp" class="input-field">
                    </div>
                    <div class="input-group mb-4">
                        <label for="config_selected_db_config">Select Stored DB Config for Pipeline:</label>
                        <select id="config_selected_db_config" class="input-field">
                            <option value="">-- No DB Config Selected --</option>
                        </select>
                        <p class="text-sm text-gray-500 mt-1">This DB config will be included in the pipeline's configuration.</p>
                    </div>
                    <button class="btn btn-primary w-full" onclick="saveAppConfiguration()">Save App Configuration</button>
                    <div class="mt-4">
                        <h4 class="font-semibold text-gray-600 mb-2">Current Active Configuration:</h4>
                        <div id="appConfigStatus" class="bg-gray-50 p-3 rounded-lg text-sm overflow-x-auto">No active configuration.</div>
                    </div>
                </div>
            </div>

            <!-- Fetch Table Data Tab -->
            <div id="fetchTableDataTab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Fetch Raw Table Data (JSON)</h2>
                <p class="text-gray-600 mb-4">Select a previously saved DB configuration to directly fetch data as JSON.</p>
                <div class="card">
                    <div class="input-group mb-4">
                        <label for="fetch_selected_db_config">Select Stored DB Config to Fetch From:</label>
                        <select id="fetch_selected_db_config" class="input-field">
                            <option value="">-- Select a DB Config --</option>
                        </select>
                        <p class="text-sm text-gray-500 mt-1">This will use the SQL query associated with the selected config.</p>
                    </div>
                    <button class="btn btn-primary w-full mt-4" onclick="fetchTableDataFromSelectedConfig()">Fetch Data</button>
                </div>
                <div id="tableDataOutput" class="mt-4 overflow-x-auto"></div>
            </div>


            <!-- Run Pipeline Tab -->
            <div id="pipelineTab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Run Data Processing Pipeline</h2>
                <p class="text-gray-600 mb-4">The pipeline will use the <b>active application configuration</b> and <b>all saved inputs</b>.</p>
                <button class="btn btn-primary w-full" onclick="runPipeline()">Run Pipeline with Current Config & Inputs</button>
                <div id="pipelineStatus" class="mt-4"></div>
                <div id="downloadLink" class="mt-4"></div>
                <div id="wsNotifications" class="mt-4 bg-blue-100 text-blue-800 p-3 rounded-lg hidden">
                    <h3 class="font-bold">Live Notifications (WebSocket):</h3>
                    <pre id="wsMessages" class="whitespace-pre-wrap text-sm"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Container for desktop-like notifications -->
    <div id="notificationContainer"></div>

    <script>
        // API_BASE_URL now correctly points to the /api prefix
        const API_BASE_URL = window.location.origin + '/api';
        const WS_URL = 'ws://' + window.location.host + '/api/notifications/ws/notify';
        let ws;
        let inputCount = 0; // Counter for dynamic input fields

        // Global storage for DB configs fetched from the API
        let storedDbConfigs = { external_db_configs: [], local_db_configs: [] };
        let activeAppConfiguration = null; // Store the last fetched active configuration

        // --- Utility Functions ---
        function showNotification(message, type = 'info', duration = 5000) {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification-item ${type}`;
            notification.textContent = message;
            container.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('fade-out');
                notification.addEventListener('animationend', () => notification.remove());
            }, duration);
        }

        function displayRawJson(elementId, data) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<pre class="bg-gray-50 p-3 rounded-lg text-sm overflow-x-auto">${JSON.stringify(data, null, 2)}</pre>`;
        }

        function displayTable(elementId, data) {
            const element = document.getElementById(elementId);
            if (!data || data.length === 0) {
                element.innerHTML = '<p class="text-gray-500">No data to display.</p>';
                return;
            }

            let html = '<table class="min-w-full divide-y divide-gray-200 shadow-md rounded-lg overflow-hidden">';
            // Table header
            html += '<thead class="bg-gray-50"><tr>';
            for (const key in data[0]) {
                html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${key}</th>`;
            }
            html += '</tr></thead>';

            // Table body
            html += '<tbody class="bg-white divide-y divide-gray-200">';
            data.forEach(row => {
                html += '<tr>';
                for (const key in row) {
                    // Handle complex objects / arrays in table cells by stringifying
                    let cellContent = row[key];
                    if (typeof cellContent === 'object' && cellContent !== null) {
                        cellContent = JSON.stringify(cellContent);
                    }
                    html += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${cellContent}</td>`;
                }
                html += '</tr>';
            });
            html += '</tbody></table>';
            element.innerHTML = html;
        }
        
        // --- Tab Management ---
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            document.querySelectorAll('.tab-link').forEach(link => { // Changed to tab-link
                link.classList.remove('active');
            });

            document.getElementById(tabId).classList.remove('hidden');
            document.querySelector(`.tab-link[data-tab="${tabId}"]`).classList.add('active');

            // Specific actions when a tab is shown
            if (tabId === 'dbConfigTab') {
                listDbConfigs(); // Refresh DB list when tab is shown
            } else if (tabId === 'inputsTab') {
                listInputs(); // Refresh Inputs list
            } else if (tabId === 'configureAppTab') {
                getAndDisplayActiveAppConfig(); // Fetch and display active config
                populateDbConfigSelect('config_selected_db_config'); // Populate DB dropdown for app config
            } else if (tabId === 'fetchTableDataTab') {
                populateDbConfigSelect('fetch_selected_db_config'); // Populate DB dropdown for fetch tab
                document.getElementById('tableDataOutput').innerHTML = ''; // Clear previous output
            } else if (tabId === 'pipelineTab') {
                connectWebSocket(); // Connect WebSocket when pipeline tab is active
            } else {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close(); // Close WebSocket if leaving pipeline tab
                }
            }
        }

        // --- WebSocket ---
        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket already open or connecting.");
                return;
            }
            const wsMessagesElement = document.getElementById('wsMessages');
            const wsNotificationsBox = document.getElementById('wsNotifications');
            wsMessagesElement.textContent = ''; // Clear previous messages
            wsNotificationsBox.classList.remove('hidden');

            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                wsMessagesElement.textContent += 'WebSocket connected.\n';
                showNotification('WebSocket connected to receive live updates.', 'info');
                console.log('WebSocket connected.');
            };

            ws.onmessage = (event) => {
                const message = event.data;
                wsMessagesElement.textContent += `Received: ${message}\n`;
                wsMessagesElement.scrollTop = wsMessagesElement.scrollHeight; // Scroll to bottom
                console.log('Received:', message);
                
                // Show desktop-like notification for important messages
                if (message.includes("Download processing") || message.includes("Download started") || message.includes("Download finished")) {
                    showNotification(message, 'info');
                }

                // Handle download specific messages to enable download link
                if (message.includes("Download started") || message.includes("Download finished")) { // Changed to match "finished" for link
                    const taskIdMatch = message.match(/task ([\w-]+)/);
                    if (taskIdMatch && taskIdMatch[1]) {
                        const taskId = taskIdMatch[1];
                        const downloadLinkDiv = document.getElementById('downloadLink');
                        // Ensure the path matches the download router's path
                        downloadLinkDiv.innerHTML = `<a href="${API_BASE_URL}/downloads/download/${taskId}" target="_blank" class="btn btn-primary mt-4">Download Processed File (${taskId}.zip)</a>`;
                        if (message.includes("Download finished")) {
                             showNotification(`Download finished for task ${taskId}. File is ready!`, 'success');
                        }
                    }
                }
            };

            ws.onclose = (event) => {
                wsMessagesElement.textContent += `WebSocket disconnected: ${event.code} ${event.reason}\n`;
                showNotification('WebSocket disconnected from server.', 'warning');
                console.log('WebSocket disconnected:', event);
                // wsNotificationsBox.classList.add('hidden'); // Keep visible for log of disconnect
            };

            ws.onerror = (error) => {
                wsMessagesElement.textContent += `WebSocket error: ${error.message || 'Unknown error'}\n`;
                showNotification('WebSocket error occurred. Check console for details.', 'error');
                console.error('WebSocket error:', error);
            };
        }

        // --- DB Configuration (Manage stored configs) Functions ---
        function showDbForm(type) {
            document.getElementById('externalDbForm').classList.add('hidden');
            document.getElementById('localDbForm').classList.add('hidden');
            if (type === 'external') {
                document.getElementById('externalDbForm').classList.remove('hidden');
            } else if (type === 'local') {
                document.getElementById('localDbForm').classList.remove('hidden');
            }
        }

        async function saveDbConfig(type) {
            let url = '';
            let payload = {};

            if (type === 'external') {
                url = `${API_BASE_URL}/db_management/db/external`;
                payload = {
                    db_type: document.getElementById('ext_db_type').value,
                    username: document.getElementById('ext_username').value,
                    password: document.getElementById('ext_password').value,
                    host: document.getElementById('ext_host').value,
                    port: document.getElementById('ext_port').value,
                    db_name: document.getElementById('ext_db_name').value,
                    sql_query: document.getElementById('ext_sql_query').value,
                    driver: document.getElementById('ext_driver').value.trim() || null // Pass null if empty
                };
            } else if (type === 'local') {
                url = `${API_BASE_URL}/db_management/db/local`;
                payload = {
                    db_file_path: document.getElementById('loc_db_path').value,
                    initial_sql: document.getElementById('loc_initial_sql').value.trim() || null, // Pass null if empty
                    sql_query: document.getElementById('loc_sql_query').value
                };
            } else {
                showNotification('Invalid DB type selected.', 'error');
                return;
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(`DB Config saved: ${data.message}`, 'success');
                    listDbConfigs(); // Refresh the list of stored DBs
                    populateDbConfigSelect('config_selected_db_config'); // Refresh DB dropdown in App Config tab
                    populateDbConfigSelect('fetch_selected_db_config'); // Refresh DB dropdown in Fetch tab
                } else {
                    showNotification(`Error saving DB Config: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error saving DB Config: ${error.message}`, 'error');
                console.error('Save DB Config error:', error);
            }
        }

        async function listDbConfigs() {
            try {
                const response = await fetch(`${API_BASE_URL}/db_management/db/list`);
                const data = await response.json();
                if (response.ok) {
                    storedDbConfigs = data; // Store globally for other tabs
                    const listDiv = document.getElementById('dbConfigList');
                    listDiv.innerHTML = ''; // Clear previous list

                    let html = '<h4 class="font-semibold text-gray-600 mb-2">External DBs:</h4>';
                    if (data.external_db_configs && data.external_db_configs.length > 0) {
                        data.external_db_configs.forEach(db => {
                            html += `<div class="card p-3 mb-2 text-sm">
                                <p><strong>Type:</strong> ${db.db_type}</p>
                                <p><strong>Host:</strong> ${db.host}:${db.port}</p>
                                <p><strong>DB Name:</strong> ${db.db_name}</p>
                                <p><strong>User:</strong> ${db.username}</p>
                                <p><strong>Driver:</strong> ${db.driver || 'N/A'}</p> <!-- Display Driver -->
                                <p><strong>SQL Query:</strong> ${db.sql_query.substring(0, 50)}...</p>
                            </div>`;
                        });
                    } else {
                        html += '<p class="text-gray-500">No external DB configurations stored.</p>';
                    }

                    html += '<h4 class="font-semibold text-gray-600 mt-4 mb-2">Local SQLite DBs:</h4>';
                    if (data.local_db_configs && data.local_db_configs.length > 0) {
                        data.local_db_configs.forEach(db => {
                            html += `<div class="card p-3 mb-2 text-sm">
                                <p><strong>Path:</strong> ${db.db_file_path}</p>
                                <p><strong>Initial SQL:</strong> ${db.initial_sql ? db.initial_sql.substring(0, 50) + '...' : 'None'}</p>
                                <p><strong>SQL Query:</strong> ${db.sql_query.substring(0, 50)}...</p>
                            </div>`;
                        });
                    } else {
                        html += '<p class="text-gray-500">No local SQLite DB configurations stored.</p>';
                    }
                    listDiv.innerHTML = html;
                } else {
                    showNotification(`Error listing DBs: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error listing DBs: ${error.message}`, 'error');
                console.error('List DB Configs error:', error);
            }
        }

        async function clearAllDbConfigs() {
            if (!confirm('Are you sure you want to clear ALL stored DB configurations? This cannot be undone.')) return;
            try {
                // Call the combined clear endpoint
                const response = await fetch(`${API_BASE_URL}/db_management/db/clear/all`, { method: 'DELETE' });
                const data = await response.json();

                if (response.ok) {
                    showNotification(data.message, 'success');
                    listDbConfigs(); // Refresh the list
                    populateDbConfigSelect('config_selected_db_config'); // Refresh DB dropdowns
                    populateDbConfigSelect('fetch_selected_db_config');
                } else {
                    showNotification(`Error clearing DB configurations: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error clearing DBs: ${error.message}`, 'error');
                console.error('Clear All DB Configs error:', error);
            }
        }

        // --- Inputs (Rename/Reorder) Functions ---
        function addInputField(inputData = {}) {
            inputCount++;
            const container = document.getElementById('inputFormsContainer');
            const inputFormId = `inputForm_${inputCount}`;
            const html = `
                <div id="${inputFormId}" class="card flex flex-col md:flex-row gap-4 mb-4 items-end">
                    <div class="input-group flex-1">
                        <label for="input_name_${inputCount}">Input Name (Unique)</label>
                        <input type="text" id="input_name_${inputCount}" class="input-field" placeholder="e.g., product_rename" value="${inputData.name || ''}">
                    </div>
                    <div class="input-group w-32">
                        <label for="input_col_idx_${inputCount}">Col Index (0-based)</label>
                        <input type="number" id="input_col_idx_${inputCount}" class="input-field" placeholder="e.g., 0" value="${inputData.column !== null && inputData.column !== undefined ? inputData.column : ''}">
                    </div>
                    <div class="input-group flex-1">
                        <label for="input_new_name_${inputCount}">New Column Name (Optional)</label>
                        <input type="text" id="input_new_name_${inputCount}" class="input-field" placeholder="e.g., NewProductName" value="${inputData.name || ''}">
                    </div>
                    <div class="input-group w-32">
                        <label for="input_new_order_${inputCount}">New Order (Optional)</label>
                        <input type="number" id="input_new_order_${inputCount}" class="input-field" placeholder="e.g., 0" value="${inputData.change_order !== null && inputData.change_order !== undefined ? inputData.change_order : ''}">
                    </div>
                    <button class="btn btn-secondary px-4 py-2" onclick="document.getElementById('${inputFormId}').remove(); updateInputCount();">Remove</button>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', html);
        }

        function updateInputCount() {
            inputCount = document.querySelectorAll('[id^="inputForm_"]').length;
        }

        async function saveAllInputs() {
            const inputs = [];
            document.querySelectorAll('[id^="inputForm_"]').forEach(formDiv => {
                const id = formDiv.id.split('_')[1];
                const name = document.getElementById(`input_name_${id}`).value;
                const col_idx_str = document.getElementById(`input_col_idx_${id}`).value;
                const new_name = document.getElementById(`input_new_name_${id}`).value;
                const new_order_str = document.getElementById(`input_new_order_${id}`).value;

                if (!name.trim()) {
                    showNotification(`Input name is required for input form #${id}. Skipping this entry.`, 'warning');
                    return;
                }

                const col_idx = col_idx_str !== '' ? parseInt(col_idx_str) : null;
                const new_order = new_order_str !== '' ? parseInt(new_order_str) : null;

                inputs.push({
                    name: name.trim(),
                    column: col_idx,
                    name: new_name.trim() || null, // Overwrites 'name' with 'new_name'
                    change_order: new_order
                });
            });

            try {
                const response = await fetch(`${API_BASE_URL}/config/inputs/bulk`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(inputs)
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(data.message, 'success');
                    listInputs(); // Refresh the list of inputs after saving
                } else {
                    showNotification(`Error saving inputs: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error saving inputs: ${error.message}`, 'error');
                console.error('Save Inputs error:', error);
            }
        }

        async function listInputs() {
            try {
                const response = await fetch(`${API_BASE_URL}/config/inputs/list`);
                const data = await response.json();
                if (response.ok) {
                    const listDiv = document.getElementById('inputsList');
                    listDiv.innerHTML = ''; // Clear previous list

                    if (data.inputs && data.inputs.length > 0) {
                        let html = '<h4 class="font-semibold text-gray-600 mb-2">Current Inputs:</h4>';
                        data.inputs.forEach(input => {
                            html += `<div class="card p-3 mb-2 text-sm">
                                <p><strong>Name:</strong> ${input.name}</p>
                                <p><strong>Column Index:</strong> ${input.column !== null ? input.column : 'N/A'}</p>
                                <p><strong>New Name:</strong> ${input.name !== null ? input.name : 'N/A'}</p>
                                <p><strong>New Order:</strong> ${input.change_order !== null ? input.change_order : 'N/A'}</p>
                            </div>`;
                        });
                        listDiv.innerHTML = html;
                    } else {
                        listDiv.innerHTML = '<p class="text-gray-500">No inputs stored.</p>';
                    }

                    // Re-populate dynamic forms based on fetched data
                    document.getElementById('inputFormsContainer').innerHTML = ''; // Clear all existing forms
                    inputCount = 0; // Reset counter
                    if (data.inputs && data.inputs.length > 0) {
                        data.inputs.forEach(input => {
                            addInputField(input); // Add a new field and pre-fill with fetched data
                        });
                    } else {
                        addInputField(); // Add one empty field if no inputs
                    }

                } else {
                    showNotification(`Error listing inputs: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error listing inputs: ${error.message}`, 'error');
                console.error('List Inputs error:', error);
            }
        }

        async function clearAllInputs() {
            if (!confirm('Are you sure you want to clear ALL stored inputs? This cannot be undone.')) return;
            try {
                const response = await fetch(`${API_BASE_URL}/config/inputs/clear`, { method: 'DELETE' });
                const data = await response.json();
                if (response.ok) {
                    showNotification(data.message, 'success');
                    listInputs(); // Refresh the list and forms
                } else {
                    showNotification(`Error clearing inputs: ${data.detail || response.statusText}`, 'error');
                }
            } catch (error) {
                showNotification(`Network error clearing inputs: ${error.message}`, 'error');
                console.error('Clear Inputs error:', error);
            }
        }

        // --- App Configuration Functions ---
        async function getAndDisplayActiveAppConfig() {
            const appConfigStatusDiv = document.getElementById('appConfigStatus');
            try {
                const response = await fetch(`${API_BASE_URL}/config/configure/active`);
                const data = await response.json();
                if (response.ok && data.configuration) {
                    activeAppConfiguration = data.configuration; // Store globally
                    displayRawJson('appConfigStatus', activeAppConfiguration);
                    // Pre-fill form fields with active config
                    document.getElementById('config_file_type').value = activeAppConfiguration.file_type || 'csv';
                    document.getElementById('config_tmp_dir').value = activeAppConfiguration.tmp_dir || '';

                    // Select the correct DB config in the dropdown
                    if (activeAppConfiguration.db_config) {
                        const selectedDbOption = findOptionForDbConfig(activeAppConfiguration.db_config);
                        document.getElementById('config_selected_db_config').value = selectedDbOption || '';
                    } else {
                        document.getElementById('config_selected_db_config').value = '';
                    }
                } else {
                    activeAppConfiguration = null;
                    appConfigStatusDiv.innerHTML = 'No active configuration.';
                    document.getElementById('config_file_type').value = 'csv';
                    document.getElementById('config_tmp_dir').value = '';
                    document.getElementById('config_selected_db_config').value = '';
                }
            } catch (error) {
                showNotification(`Failed to fetch active app config: ${error.message}`, 'error');
                console.error('Fetch Active App Config error:', error);
                appConfigStatusDiv.innerHTML = '<p class="text-red-500">Error fetching active configuration.</p>';
            }
        }

        function findOptionForDbConfig(dbConfig) {
            // Helper to find the matching option value for a given dbConfig object
            if (dbConfig.db_type === 'sqlite' || dbConfig.db_file_path) { // Check for db_type 'sqlite' or presence of db_file_path for local
                const index = storedDbConfigs.local_db_configs.findIndex(
                    locDb => locDb.db_file_path === dbConfig.db_file_path &&
                             locDb.sql_query === dbConfig.sql_query &&
                             (locDb.initial_sql || null) === (dbConfig.initial_sql || null)
                );
                return index !== -1 ? `local_${index}` : null;
            } else { // Assume external DB
                const index = storedDbConfigs.external_db_configs.findIndex(
                    extDb => extDb.db_type === dbConfig.db_type &&
                             extDb.host === dbConfig.host &&
                             extDb.port === dbConfig.port &&
                             extDb.db_name === dbConfig.db_name &&
                             extDb.username === dbConfig.username &&
                             extDb.sql_query === dbConfig.sql_query &&
                             (extDb.driver || null) === (dbConfig.driver || null) // Include driver in comparison
                );
                return index !== -1 ? `external_${index}` : null;
            }
        }


        async function populateDbConfigSelect(selectElementId) {
            await listDbConfigs(); // Ensure storedDbConfigs is updated first
            const selectElement = document.getElementById(selectElementId);
            selectElement.innerHTML = '<option value="">-- No DB Config Selected --</option>'; // Default option

            // Add external DBs to the dropdown
            storedDbConfigs.external_db_configs.forEach((db, index) => {
                const option = document.createElement('option');
                option.value = `external_${index}`; // Store type and index in the value
                option.textContent = `External: ${db.db_type} - ${db.db_name} (${db.host}:${db.port})` + (db.driver ? ` [Driver: ${db.driver.substring(0,20)}...]` : ''); // Display Driver
                selectElement.appendChild(option);
            });

            // Add local DBs to the dropdown
            storedDbConfigs.local_db_configs.forEach((db, index) => {
                const option = document.createElement('option');
                option.value = `local_${index}`; // Store type and index in the value
                option.textContent = `Local: ${db.db_file_path}`;
                selectElement.appendChild(option);
            });

            // Re-select the active DB config if this is the app config select
            if (selectElementId === 'config_selected_db_config' && activeAppConfiguration && activeAppConfiguration.db_config) {
                 const selectedOption = findOptionForDbConfig(activeAppConfiguration.db_config);
                 if (selectedOption) {
                     selectElement.value = selectedOption;
                 }
            } else if (selectElementId === 'fetch_selected_db_config') {
                 // For fetch tab, no initial selection based on app config needed.
                 // User will select manually.
            }
        }

        async function saveAppConfiguration() {
            const fileType = document.getElementById('config_file_type').value;
            const tmpDir = document.getElementById('config_tmp_dir').value.trim() || null;
            const selectedDbOption = document.getElementById('config_selected_db_config').value;

            let dbConfigPayload = null;
            if (selectedDbOption) {
                const [type, index] = selectedDbOption.split('_');
                if (type === 'external') {
                    dbConfigPayload = storedDbConfigs.external_db_configs[parseInt(index)];
                } else if (type === 'local') {
                    dbConfigPayload = storedDbConfigs.local_db_configs[parseInt(index)];
                }
            }

            const payload = {
                file_type: fileType,
                tmp_dir: tmpDir,
                db_config: dbConfigPayload // This will be null if no DB is selected
            };

            try {
                const response = await fetch(`${API_BASE_URL}/config/configure`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(data.message, 'success');
                    activeAppConfiguration = data.configuration; // Update global active config
                    displayRawJson('appConfigStatus', activeAppConfiguration);
                } else {
                    showNotification(`Error saving app config: ${data.detail || response.statusText}`, 'error');
                    displayRawJson('appConfigStatus', data);
                }
            } catch (error) {
                showNotification(`Network error saving app config: ${error.message}`, 'error');
                console.error('Save App Config error:', error);
            }
        }

        // --- Fetch Table Data Tab Functions ---
        async function fetchTableDataFromSelectedConfig() {
            const tableDataOutputDiv = document.getElementById('tableDataOutput');
            tableDataOutputDiv.innerHTML = '<p class="text-gray-500">Fetching data...</p>';
            
            const selectedDbOption = document.getElementById('fetch_selected_db_config').value;
            if (!selectedDbOption) {
                showNotification('Please select a DB Configuration to fetch data from.', 'warning');
                tableDataOutputDiv.innerHTML = '<p class="text-gray-500">No DB config selected.</p>';
                return;
            }

            let dbConfigPayload = null;
            const [type, index] = selectedDbOption.split('_');
            if (type === 'external') {
                dbConfigPayload = storedDbConfigs.external_db_configs[parseInt(index)];
            } else if (type === 'local') {
                dbConfigPayload = storedDbConfigs.local_db_configs[parseInt(index)];
            }

            if (!dbConfigPayload) {
                 showNotification('Selected DB Configuration not found in stored list. Please refresh and re-select.', 'error');
                 tableDataOutputDiv.innerHTML = '<p class="text-red-500">Error: Selected config not found.</p>';
                 return;
            }

            // The `db_config` payload for /tables/table/data needs `sql_query`
            if (!dbConfigPayload.sql_query || dbConfigPayload.sql_query.trim() === '') {
                showNotification('Selected DB config has no SQL query defined. Please update the config.', 'error');
                tableDataOutputDiv.innerHTML = '<p class="text-red-500">Error: Selected config has no SQL query.</p>';
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/tables/table/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dbConfigPayload) // Send the selected DB config directly
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(data.message, 'success');
                    displayTable('tableDataOutput', data.data);
                } else {
                    showNotification(`Error fetching table data: ${data.detail || response.statusText}`, 'error');
                    displayRawJson('tableDataOutput', data);
                }
            } catch (error) {
                showNotification(`Network error fetching table data: ${error.message}`, 'error');
                console.error('Fetch Table Data error:', error);
            }
        }


        // --- Run Pipeline Functions ---
        async function runPipeline() {
            const pipelineStatusDiv = document.getElementById('pipelineStatus');
            pipelineStatusDiv.innerHTML = '<p class="text-gray-500">Starting pipeline...</p>';
            document.getElementById('downloadLink').innerHTML = '';

            // Get the current active application configuration
            let currentAppConfig = null;
            try {
                const configResponse = await fetch(`${API_BASE_URL}/config/configure/active`);
                const configData = await configResponse.json();
                if (configResponse.ok && configData.configuration) {
                    currentAppConfig = configData.configuration;
                } else {
                    showNotification('No active application configuration found. Please save one first.', 'error');
                    pipelineStatusDiv.innerHTML = '<p class="text-red-500">Pipeline aborted: No active configuration.</p>';
                    return;
                }
            } catch (error) {
                showNotification(`Failed to retrieve active configuration: ${error.message}`, 'error');
                pipelineStatusDiv.innerHTML = '<p class="text-red-500">Pipeline aborted due to config error.</p>';
                return;
            }

            // Get all current inputs
            let currentInputs = [];
            try {
                const inputsResponse = await fetch(`${API_BASE_URL}/config/inputs/list`);
                const inputsData = await inputsResponse.json();
                if (inputsResponse.ok && inputsData.inputs) {
                    currentInputs = inputsData.inputs;
                }
            } catch (error) {
                showNotification(`Failed to retrieve inputs: ${error.message}. Proceeding without inputs.`, 'warning');
            }

            // Ensure db_config is part of the current active configuration
            if (!currentAppConfig.db_config) {
                 showNotification('No DB configuration selected in active app configuration. Pipeline aborted.', 'error');
                 pipelineStatusDiv.innerHTML = '<p class="text-red-500">Pipeline aborted: Missing DB config.</p>';
                 return;
            }

            const taskId = 'task_' + Date.now();

            const payload = {
                task_id: taskId,
                inputs: currentInputs,
                configuration: currentAppConfig
            };

            try {
                const response = await fetch(`${API_BASE_URL}/pipeline/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(`Pipeline started for task ${data.task_id}. Check live notifications.`, 'info');
                    pipelineStatusDiv.innerHTML = `<p class="text-green-600">Pipeline initiated. Task ID: ${data.task_id}. Check live notifications for status updates.</p>`;
                } else {
                    showNotification(`Error running pipeline: ${data.detail || response.statusText}`, 'error');
                    pipelineStatusDiv.innerHTML = `<p class="text-red-500">Pipeline failed: ${data.detail || response.statusText}</p>`;
                }
            } catch (error) {
                showNotification(`Network error running pipeline: ${error.message}`, 'error');
                console.error('Run Pipeline error:', error);
                pipelineStatusDiv.innerHTML = '<p class="text-red-500">Pipeline aborted due to network error.</p>';
            }
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // Event listeners for navbar tabs
            document.querySelectorAll('.tab-link').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault(); // Prevent default link behavior
                    showTab(event.target.dataset.tab);
                });
            });

            showTab('dbConfigTab'); // Show DB config tab by default
            // Initial calls for UI population (some are triggered by showTab)
        });
    </script>
</body>
</html>

