import json
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, ValidationError, Field

# Local imports for AppConfig schema (includes nested Configure)
from app.core.schemas.input_schema import Configure, ExternalDBSchema, LocalDBSchema

# Set up logging for the config module
logger = logging.getLogger(__name__)

# --- Pydantic Application Configuration Schema ---
class AppConfig(BaseModel):
    """
    Defines the schema for the application's global configuration file (config.json).
    This includes application-wide constants and a default processing configuration.
    """
    URL: str = Field("", description="Base URL for external services (if any).")
    TEMP_DIR: str = Field("tmp", description="Root directory for temporary files generated by the application.")
    
    # The default application configuration, which can be loaded at startup
    # and potentially overridden by API calls for specific tasks.
    default_configure: Optional[Configure] = Field(
        None, description="Default data processing and export configuration for tasks."
    )

# --- Configuration Loading Logic ---

# Define the expected path to the configuration file
CONFIG_PATH = Path("app/core/json/config.json")

# Global variables to hold the loaded and validated configuration values
URL: str
TEMP_DIR: Path # Stored as a Path object for consistent filesystem operations
DEFAULT_APP_CONFIGURE: Optional[Configure] = None # Stores the default Configure object

try:
    if CONFIG_PATH.exists():
        logger.info(f"Attempting to load application configuration from: {CONFIG_PATH.resolve()}")
        with CONFIG_PATH.open("r", encoding="utf-8") as file:
            config_data: Dict[str, Any] = json.load(file)

        # Validate the loaded JSON data against the AppConfig Pydantic model
        app_config_instance = AppConfig(**config_data)

        # Assign validated values to global variables
        URL = app_config_instance.URL
        TEMP_DIR = Path(app_config_instance.TEMP_DIR) # Convert string path to Path object
        DEFAULT_APP_CONFIGURE = app_config_instance.default_configure

        logger.info("Application configuration loaded successfully.")

    else:
        logger.warning(f"Configuration file not found at: {CONFIG_PATH.resolve()}. "
                       "Proceeding with default application settings (no config.json).")
        # If config.json is not found, initialize AppConfig with its default values
        app_config_instance = AppConfig()
        URL = app_config_instance.URL
        TEMP_DIR = Path(app_config_instance.TEMP_DIR)
        DEFAULT_APP_CONFIGURE = app_config_instance.default_configure

except json.JSONDecodeError as e:
    logger.exception(f"Failed to parse config.json: Invalid JSON format. Error: {e}")
    raise RuntimeError(f"Failed to parse config.json: Invalid JSON format. Please check the file. Error: {e}") from e
except ValidationError as e:
    logger.exception(f"Configuration validation failed for {CONFIG_PATH.resolve()}. Errors: {e.errors()}")
    raise RuntimeError(f"Configuration validation failed. Please check config.json against the schema. Errors: {e.errors()}") from e
except Exception as e:
    logger.exception(f"An unexpected error occurred while loading configuration from {CONFIG_PATH.resolve()}.")
    raise RuntimeError(f"An unexpected error occurred during configuration loading: {e}") from e

# Ensure the temporary directory specified in config (or default) exists
TEMP_DIR.mkdir(parents=True, exist_ok=True)
logger.info(f"Ensured temporary root directory exists at: {TEMP_DIR.resolve()}")

# --- Example `config.json` content for testing ---
# For an in-memory SQLite DB:
"""
{
    "URL": "http://my-service.com/api",
    "TEMP_DIR": "temp_app_data",
    "default_configure": {
        "file_type": "json",
        "db_config": {
            "db_type": "sqlite",
            "db_file_path": ":memory:",
            "initial_sql": "CREATE TABLE products (id INTEGER, name TEXT, price REAL); INSERT INTO products VALUES (1, 'Laptop', 1200.00), (2, 'Mouse', 25.50);",
            "sql_query": "SELECT * FROM products;"
        }
    }
}
"""
# For an external PostgreSQL DB:
"""
{
    "URL": "http://my-service.com/api",
    "TEMP_DIR": "temp_external_data",
    "default_configure": {
        "file_type": "csv",
        "db_config": {
            "db_type": "postgresql",
            "username": "user",
            "password": "password",
            "host": "localhost",
            "port": "5432",
            "db_name": "testdb",
            "sql_query": "SELECT id, product_name FROM public.products LIMIT 50;"
        }
    }
}
"""
